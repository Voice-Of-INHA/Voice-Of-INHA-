<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <title>STT Streaming Test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, Segoe UI, Apple SD Gothic Neo, Malgun Gothic, sans-serif;
      padding: 24px;
      background: #f7f7fb
    }

    button {
      padding: 10px 14px;
      border-radius: 10px;
      border: none;
      background: #4f46e5;
      color: #fff;
      font-weight: 600;
      margin-right: 8px
    }

    button.stop {
      background: #dc2626
    }

    #log {
      white-space: pre-wrap;
      background: #fff;
      border: 1px solid #e5e7eb;
      padding: 12px;
      border-radius: 12px;
      height: 320px;
      overflow: auto;
      margin-top: 12px
    }

    code {
      background: #eef;
      padding: 2px 6px;
      border-radius: 6px
    }
  </style>
</head>

<body>
  <h1>STT Streaming Test</h1>
  <p>마이크를 켜면 브라우저에서 16k PCM(int16)으로 다운샘플링하여 WebSocket <code>/voice-guard/ws/stt</code>로 전송합니다.</p>
  <button id="btnStart">녹음 시작</button>
  <button id="btnStop" class="stop">녹음 중지</button>
  <div id="log"></div>

  <script>
    const log = (m) => {
      const el = document.getElementById("log");
      el.textContent += m + "\n";
      el.scrollTop = el.scrollHeight;
    };

    let ws, audioCtx, mediaStream, src, workletNode;

    async function start() {
      if (ws && ws.readyState === WebSocket.OPEN) return;
      ws = new WebSocket((location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/voice-guard/ws/stt");
      ws.onopen = () => log("WS 연결됨");
      ws.onmessage = (ev) => log(ev.data);
      ws.onclose = () => log("WS 종료");

      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      audioCtx = new AudioContext({ sampleRate: 48000 });
      await audioCtx.audioWorklet.addModule(URL.createObjectURL(new Blob([`
    class Pcm16Worklet extends AudioWorkletProcessor {
      constructor() { super(); this.buf=[]; this.ratio=sampleRate/16000; this.phase=0; }
      process(inputs) {
        if (!inputs.length || !inputs[0].length) return true;
        const ch = inputs[0][0];
        for (let i=0;i<ch.length;i++) {
          this.phase += 1;
          if (this.phase >= this.ratio) {
            this.phase -= this.ratio;
            this.buf.push(ch[i]);
          }
        }
        if (this.buf.length >= 2560) {
          const pcm = new Int16Array(this.buf.length);
          for (let i=0;i<this.buf.length;i++) {
            let s = Math.max(-1, Math.min(1, this.buf[i]));
            pcm[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
          }
          this.port.postMessage(pcm.buffer, [pcm.buffer]);
          this.buf = [];
        }
        return true;
      }
    }
    registerProcessor('pcm16-worklet', Pcm16Worklet);
  `], { type: "text/javascript" })));

      src = audioCtx.createMediaStreamSource(mediaStream);
      workletNode = new AudioWorkletNode(audioCtx, 'pcm16-worklet');
      workletNode.port.onmessage = (e) => {
        if (ws && ws.readyState === WebSocket.OPEN) ws.send(e.data);
      };
      src.connect(workletNode);
      // 에코 방지: 스피커 출력 연결하지 않음
      // workletNode.connect(audioCtx.destination);
      log("▶️ started (mic → 16k PCM → WS)");
    }

    function stop() {
      try { if (ws && ws.readyState === WebSocket.OPEN) ws.send("__END__"); } catch (e) { }
      try { ws && ws.close(); } catch (e) { }
      ws = null;
      try { workletNode && workletNode.disconnect(); } catch (e) { }
      try { src && src.disconnect(); } catch (e) { }
      try { mediaStream && mediaStream.getTracks().forEach(t => t.stop()); } catch (e) { }
      try { audioCtx && audioCtx.close(); } catch (e) { }
      log("⏹ stopped");
    }

    document.getElementById("btnStart").onclick = start;
    document.getElementById("btnStop").onclick = stop;
  </script>
</body>

</html>